"use strict";(self.webpackChunkfoss_guru=self.webpackChunkfoss_guru||[]).push([[3431],{2141:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>l,frontMatter:()=>d,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"kits/java/Java OOP/OOPs Inside Java/method-hiding","title":"Method Hiding in Java","description":"Declaring similar static methods in parent and child classes is called method hiding. For non-static methods, it is method overriding.","source":"@site/community/kits/java/Java OOP/OOPs Inside Java/method-hiding.md","sourceDirName":"kits/java/Java OOP/OOPs Inside Java","slug":"/kits/java/Java OOP/OOPs Inside Java/method-hiding","permalink":"/foss-guru/community/kits/java/Java OOP/OOPs Inside Java/method-hiding","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"id":"method-hiding","title":"Method Hiding in Java","description":"Declaring similar static methods in parent and child classes is called method hiding. For non-static methods, it is method overriding.","sidebar_position":6},"sidebar":"community","previous":{"title":"Java instanceof Operator","permalink":"/foss-guru/community/kits/java/Java OOP/OOPs Inside Java/instanceof-operator"},"next":{"title":"Differences need to know","permalink":"/foss-guru/community/category/differences-need-to-know"}}');var s=i(4848),a=i(8453);const d={id:"method-hiding",title:"Method Hiding in Java",description:"Declaring similar static methods in parent and child classes is called method hiding. For non-static methods, it is method overriding.",sidebar_position:6},o=void 0,r={},c=[{value:"\ud83c\udfad Java Method Hiding vs. Overriding",id:"-java-method-hiding-vs-overriding",level:2},{value:"1\ufe0f\u20e3 Understanding Method Hiding with an Example",id:"1\ufe0f\u20e3-understanding-method-hiding-with-an-example",level:2},{value:"2\ufe0f\u20e3 Can We Override Static Methods by Making Them Non-static in Child Class?",id:"2\ufe0f\u20e3-can-we-override-static-methods-by-making-them-non-static-in-child-class",level:2},{value:"3\ufe0f\u20e3 Conclusion \ud83c\udfc1",id:"3\ufe0f\u20e3-conclusion-",level:2}];function h(e){const n={code:"code",em:"em",h2:"h2",img:"img",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{alt:"Banner java icon",src:i(4769).A+"",width:"370",height:"364"})}),"\n",(0,s.jsx)(n.h2,{id:"-java-method-hiding-vs-overriding",children:"\ud83c\udfad Java Method Hiding vs. Overriding"}),"\n",(0,s.jsxs)(n.p,{children:["In Java, ",(0,s.jsx)(n.strong,{children:"you can't"})," override ",(0,s.jsx)(n.code,{children:"private"}),", ",(0,s.jsx)(n.code,{children:"static"}),", or ",(0,s.jsx)(n.code,{children:"final"})," methods from the parent class in a child class. If you try with ",(0,s.jsx)(n.code,{children:"private"})," or ",(0,s.jsx)(n.code,{children:"final"})," methods, the compiler will ",(0,s.jsx)(n.strong,{children:"scream at you with errors"}),". But with ",(0,s.jsx)(n.code,{children:"static"})," methods? The compiler is like, ",(0,s.jsx)(n.em,{children:'"Go ahead, but don\'t call it overriding!"'})," \ud83d\ude06"]}),"\n",(0,s.jsxs)(n.p,{children:["When you declare ",(0,s.jsx)(n.strong,{children:"static methods with the same name and arguments"})," in both parent and child classes, Java calls it ",(0,s.jsx)(n.strong,{children:"method hiding"}),", not overriding. For ",(0,s.jsx)(n.strong,{children:"non-static"})," methods, it's real ",(0,s.jsx)(n.strong,{children:"method overriding"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"1\ufe0f\u20e3-understanding-method-hiding-with-an-example",children:"1\ufe0f\u20e3 Understanding Method Hiding with an Example"}),"\n",(0,s.jsxs)(n.p,{children:["Check out this code where both ",(0,s.jsx)(n.code,{children:"Parent"})," and ",(0,s.jsx)(n.code,{children:"Child"})," classes have a static method ",(0,s.jsx)(n.code,{children:"display()"}),". Everything compiles fine, no compiler tantrums here. \ud83c\udf89"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class Parent {\n  static void display() {\n    System.out.println("Super");\n  }\n}\n\nclass Child extends Parent {\n  static void display() {\n    System.out.println("Sub");\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now, let\u2019s test it:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:"Parent instance = new Child();\ninstance.display(); // Prints: Super\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Wait, what? Shouldn\u2019t it print ",(0,s.jsx)(n.em,{children:"Sub"}),"? \ud83e\udd14 Nope! Since ",(0,s.jsx)(n.code,{children:"display()"})," is ",(0,s.jsx)(n.strong,{children:"static"}),", Java binds it to the reference type (",(0,s.jsx)(n.code,{children:"Parent"}),") at compile time. ",(0,s.jsx)(n.strong,{children:"Static methods belong to the class, not instances!"})]}),"\n",(0,s.jsx)(n.h2,{id:"2\ufe0f\u20e3-can-we-override-static-methods-by-making-them-non-static-in-child-class",children:"2\ufe0f\u20e3 Can We Override Static Methods by Making Them Non-static in Child Class?"}),"\n",(0,s.jsxs)(n.p,{children:["Nope! \ud83d\udeab Java won't let you remove the ",(0,s.jsx)(n.code,{children:"static"})," keyword in the child class if the parent method is static. If you try, the compiler will ",(0,s.jsx)(n.em,{children:"rage quit"})," and throw an error. \ud83d\udca5"]}),"\n",(0,s.jsxs)(n.p,{children:["If we change the ",(0,s.jsx)(n.code,{children:"display()"})," method in ",(0,s.jsx)(n.code,{children:"Child"})," to a ",(0,s.jsx)(n.strong,{children:"non-static"})," method:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-java",children:'class Child extends Parent {\n  void display() {  // \u274c ERROR: Can\'t override static method\n    System.out.println("Sub");\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Java compiler: ",(0,s.jsx)(n.strong,{children:'"Excuse me, what are you trying to do?"'})," \ud83e\udd28"]}),"\n",(0,s.jsx)(n.h2,{id:"3\ufe0f\u20e3-conclusion-",children:"3\ufe0f\u20e3 Conclusion \ud83c\udfc1"}),"\n",(0,s.jsxs)(n.p,{children:["In Java, ",(0,s.jsx)(n.strong,{children:"method overriding"})," applies only to ",(0,s.jsx)(n.strong,{children:"instance methods"}),". When it comes to ",(0,s.jsx)(n.strong,{children:"static methods"}),", it\u2019s called ",(0,s.jsx)(n.strong,{children:"method hiding"}),", because static methods belong to the class, not instances."]}),"\n",(0,s.jsxs)(n.p,{children:["So, remember:\n\u2705 ",(0,s.jsx)(n.strong,{children:"Instance methods"})," \u2192 Can be overridden.\n\u2705 ",(0,s.jsx)(n.strong,{children:"Static methods"})," \u2192 Can only be hidden.\n\u2705 ",(0,s.jsx)(n.strong,{children:"Final and Private methods"})," \u2192 Cannot be overridden (Java won\u2019t even negotiate this one! \ud83d\ude45\u200d\u2642\ufe0f)."]}),"\n",(0,s.jsxs)(n.p,{children:["\ud83d\udcda Even the ",(0,s.jsx)(n.strong,{children:"Java Language Specification"})," confirms this! So if anyone tells you otherwise, hand them this doc and watch them go: \ud83d\ude32"]}),"\n",(0,s.jsx)(n.p,{children:"Happy Learning! \ud83d\ude80"})]})}function l(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},4769:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/banner-java-icon-0ae50e2293ff72244732cfbb42e27ed7.png"},8453:(e,n,i)=>{i.d(n,{R:()=>d,x:()=>o});var t=i(6540);const s={},a=t.createContext(s);function d(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);